"""
API views for menu endpoints.
"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.utils import timezone
from datetime import timedelta, date
from .models import DailyMenu
from .serializers import LunchMenuResponseSerializer


class TodayLunchMenuView(APIView):
    """
    GET /api/lunch-menu/today/
    
    Returns today's lunch menu grouped by categories.
    Only returns published menus with available, non-sold-out dishes.
    Public endpoint - no authentication required.
    """
    authentication_classes = []  # Make it publicly accessible
    permission_classes = []  # No permissions required
    
    def get(self, request):
        today = timezone.now().date()
        
        try:
            daily_menu = DailyMenu.objects.get(date=today, published=True)
        except DailyMenu.DoesNotExist:
            return Response(
                {
                    'date': str(today),
                    'published': False,
                    'categories': [],
                    'complexes': [],
                    'message': 'No menu available for today'
                },
                status=status.HTTP_200_OK
            )
        
        serializer = LunchMenuResponseSerializer(daily_menu, context={'request': request})
        return Response(serializer.data, status=status.HTTP_200_OK)


class DateLunchMenuView(APIView):
    """
    GET /api/lunch-menu/date/<date>/
    
    Returns menu for a specific date (YYYY-MM-DD format).
    Only returns published menus with available, non-sold-out dishes.
    """
    def get(self, request, date_str):
        try:
            menu_date = date.fromisoformat(date_str)
        except (ValueError, TypeError):
            return Response(
                {'error': 'Invalid date format. Use YYYY-MM-DD'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            daily_menu = DailyMenu.objects.get(date=menu_date, published=True)
        except DailyMenu.DoesNotExist:
            return Response(
                {
                    'date': str(menu_date),
                    'published': False,
                    'categories': [],
                    'message': f'No menu available for {menu_date}'
                },
                status=status.HTTP_200_OK
            )
        
        serializer = LunchMenuResponseSerializer(daily_menu, context={'request': request})
        return Response(serializer.data, status=status.HTTP_200_OK)


class WeekLunchMenuView(APIView):
    """
    GET /api/lunch-menu/week/
    
    STRICT MODE: Returns ALL published menus that exist in the database.
    NO placeholder menus, NO empty menu entries, NO autogenerated dates.
    Returns all published menus regardless of date.
    Public endpoint - no authentication required.
    """
    authentication_classes = []  # Make it publicly accessible
    permission_classes = []  # No permissions required
    
    def get(self, request):
        # STRICT: Get ALL published menus that exist in the database (no date filter)
        daily_menus = DailyMenu.objects.filter(
            published=True
        ).order_by('date')
        
        # STRICT: Serialize ONLY menus that exist - NO filling gaps
        week_menus = []
        for menu in daily_menus:
            # STRICT: Double-check published status before serializing
            if not menu.published:
                continue  # Skip unpublished menus (shouldn't happen due to filter, but extra safety)
            
            serializer = LunchMenuResponseSerializer(menu, context={'request': request})
            menu_data = serializer.data
            
            # STRICT: Verify published field is correctly set in response
            if menu_data.get('published') is not True:
                continue  # Skip if published field is not True
            
            # STRICT: Only include menus that have categories with dishes
            if menu_data.get('categories') and len(menu_data['categories']) > 0:
                # Check if any category has dishes
                has_dishes = any(
                    category.get('dishes') and len(category['dishes']) > 0
                    for category in menu_data['categories']
                )
                if has_dishes:
                    week_menus.append(menu_data)
        
        # STRICT: Return ONLY menus that exist - NO empty placeholders
        # Calculate date range from actual menus
        if week_menus:
            dates = [menu['date'] for menu in week_menus]
            start_date = min(dates)
            end_date = max(dates)
        else:
            start_date = None
            end_date = None
        
        return Response({
            'start_date': str(start_date) if start_date else None,
            'end_date': str(end_date) if end_date else None,
            'menus': week_menus  # All published menus from database
        }, status=status.HTTP_200_OK)

    def _get_menu_summary(self, menu, request):
        """Get simplified menu summary: soup, main dish, and prices."""
        daily_menu_dishes = menu.dishes.filter(available=True, sold_out=False).select_related('dish__category')
        
        soup_dish = None
        main_dish = None
        
        for menu_dish in daily_menu_dishes:
            category = menu_dish.dish.category
            category_name_en = category.name_en.lower()
            category_name_lt = category.name_lt.lower()
            
            # Find first soup
            if not soup_dish and ('soup' in category_name_en or 'sriuba' in category_name_lt):
                soup_dish = menu_dish.dish
            
            # Find first main dish (not light)
            if not main_dish:
                is_main_light = ('light' in category_name_en or 'lengvas' in category_name_lt) and ('main' in category_name_en or 'pagrindinis' in category_name_lt)
                is_main_course = ('main' in category_name_en or 'pagrindinis' in category_name_lt) and not is_main_light
                if is_main_course:
                    main_dish = menu_dish.dish
            
            # Stop if we found both
            if soup_dish and main_dish:
                break
        
        # Build summary
        summary = {
            'date': str(menu.date),
            'published': menu.published,
        }
        
        if soup_dish:
            summary['soup'] = {
                'name_lt': soup_dish.name_lt,
                'name_en': soup_dish.name_en,
                'price': str(soup_dish.price),
                'half_price': str(soup_dish.half_price) if soup_dish.half_price else None,
            }
        
        if main_dish:
            summary['main_dish'] = {
                'name_lt': main_dish.name_lt,
                'name_en': main_dish.name_en,
                'price': str(main_dish.price),
            }
        
        return summary
